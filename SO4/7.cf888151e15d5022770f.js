(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{"D+DF":function(e,a,i){"use strict";i.r(a),i.d(a,"Page3Module",function(){return t});var o=i("ofXK"),n=i("tyNb"),r=i("fXoL");const c=[{path:"",component:(()=>{class e{constructor(e){this.router=e}ngOnInit(){}OnBack(){this.router.navigate(["page2"])}OnNext(){this.router.navigate(["page4"])}OnInicio(){this.router.navigate(["frizo"])}}return e.\u0275fac=function(a){return new(a||e)(r.Ib(n.a))},e.\u0275cmp=r.Cb({type:e,selectors:[["app-page3"]],decls:70,vars:0,consts:[[1,"container"],[1,"header",3,"click"],[1,"body"],[1,"row"],[1,"col-md-1","atras"],[1,"bi","bi-caret-left","btn","btn-info","btn","btn-block","btatras",3,"click"],[1,"col-md-10"],[2,"text-align","justify"],[1,"col-md-7"],[1,"bi","bi-box-arrow-up-right"],[1,"bi","bi-shield-check"],[1,"bi","bi-share"],[1,"col-md-2"],["src","https://www.ecured.cu/images/thumb/1/13/Admt_memoria.jpg/260px-Admt_memoria.jpg",2,"height","300px"],[1,"col-md-12"],[1,"bi","bi-caret-right","btn","btn-info","btn","btn-block","btatras",3,"click"],[1,"btn","btn-block","btn-dark",3,"click"]],template:function(e,a){1&e&&(r.Lb(0,"div",0),r.Lb(1,"div",0),r.Lb(2,"div",1),r.Sb("click",function(){return a.OnInicio()}),r.Lb(3,"h2"),r.cc(4,"Aministrador de Memoria"),r.Kb(),r.Kb(),r.Kb(),r.Lb(5,"div",2),r.Lb(6,"div",3),r.Lb(7,"div",4),r.Lb(8,"button",5),r.Sb("click",function(){return a.OnBack()}),r.Kb(),r.Kb(),r.Lb(9,"div",6),r.Lb(10,"div",3),r.Lb(11,"p",7),r.cc(12," Los programas deben ser llevados a la memoria y convertirse en procesos para ser ejecutados. Cola de entrada \u2013 colecci\xf3n de programas en disco que esperan para ser llevados a la memoria para ejecuci\xf3n. La memoria principal es un dep\xf3sito de datos a los que se puede acceder r\xe1pidamente y que son compartidos por la cpu y los dispositivos de E/S. "),r.Kb(),r.Kb(),r.Lb(13,"div",3),r.Lb(14,"div",8),r.Lb(15,"p"),r.cc(16,"Cuando un programa se carga en memoria principal se convierte en procesos. "),r.Jb(17,"br"),r.cc(18," Las t\xe9cnicas que existen para la carga de programas en la memoria son: partici\xf3n fija, que es la divisi\xf3n de la memoria libre en varias partes (de igual o distinto tama\xf1o) y la partici\xf3n din\xe1mica, que son las particiones de la memoria en tama\xf1os que pueden ser variables, seg\xfan la cantidad de memoria que necesita cada proceso. "),r.Kb(),r.Lb(19,"p"),r.cc(20," Entre las principales operaciones que desarrolla la administraci\xf3n de memoria se encuentran: "),r.Jb(21,"br"),r.Lb(22,"i",9),r.cc(23," Reubicacion: que consiste en trasladar procesos activos dentro y fuera de la memoria principal para maximizar la utilizaci\xf3n del procesador"),r.Kb(),r.Jb(24,"br"),r.Lb(25,"i",10),r.cc(26," Proteccion: mecanismos que protegen los procesos que se ejecutan de interferencias de otros procesos"),r.Kb(),r.Jb(27,"br"),r.Lb(28,"i",11),r.cc(29," Uso compartido de codigos y datos: con lo que el mecanismo de protecci\xf3n permite que ciertos procesos de un mismo programa que comparten una tarea tengan memoria en com\xfan"),r.Kb(),r.Jb(30,"br"),r.Kb(),r.Kb(),r.Lb(31,"div",12),r.Jb(32,"img",13),r.Kb(),r.Kb(),r.Lb(33,"div",3),r.Lb(34,"div",14),r.Lb(35,"h4"),r.cc(36,"Asignaci\xf3n contigua"),r.Kb(),r.Lb(37,"p"),r.cc(38," Generalmente la memoria principal tiene dos particiones.-Para el sistema operativo residente que puede ser colocado en memoria baja o alta de acuerdo a la ubicaci\xf3n del vector de interrupciones-Los procesos de los usuarios se colocan en otra partici\xf3n "),r.Jb(39,"br"),r.Kb(),r.Lb(40,"h6"),r.cc(41," Asignaci\xf3n de partici\xf3n \xfanica:"),r.Kb(),r.Lb(42,"p"),r.cc(43," - Se usa el esquema de registro de reubicaci\xf3n para proteger a los procesos de los usuarios entre si, y para proteger el c\xf3digo y los datos del SO. - El registro de ubicaci\xf3n tiene el valor de la direcci\xf3n f\xedsica mas peque\xf1a; "),r.Jb(44,"br"),r.Kb(),r.Lb(45,"h6"),r.cc(46,"Asignaci\xf3n con m\xfaltiples particiones"),r.Kb(),r.Lb(47,"p"),r.cc(48,"-Hueco: Bloque de memoria disponible; se establecen varios huecos (particiones) de diferentes tama\xf1os a trav\xe9s de la memoria. -Cuando un proceso llega, es asignado a un hueco lo suficientemente grande para contenerlo -El SO mantiene informaci\xf3n acerca de las particiones asignadas."),r.Kb(),r.Kb(),r.Kb(),r.Lb(49,"div",3),r.Lb(50,"div",14),r.Lb(51,"h4"),r.cc(52,"Asignaci\xf3n con m\xfaltiples particiones fijas"),r.Kb(),r.Lb(53,"p",7),r.cc(54," Particiones configuradas por usuario, predeterminadas, se uso en OS/360/MFT (multiprogramaci\xf3n con un # fijo de tareas). Recolocaci\xf3n: El enlazador debe determinar que direcciones recolocarse vs Carga absoluta x part. "),r.Jb(55,"br"),r.cc(56," Protecci\xf3n: Bloques de 2K con clave, o Registro de base y l\xedmite. FRAGMENTACI\xd3N. no se puede aplicar overlays en este esquema de administraci\xf3n de memoria Sistemas de protecci\xf3n:-registro limite y base -protecci\xf3n por clave fragmentaci\xf3n interna: desperdicio de espacios de memoria. "),r.Kb(),r.Kb(),r.Kb(),r.Lb(57,"div",3),r.Lb(58,"div",14),r.Lb(59,"h4"),r.cc(60,"Asignaci\xf3n con particiones variables"),r.Kb(),r.Lb(61,"p",7),r.cc(62," El tama\xf1o de la partici\xf3n se establece en el momento de cargar el programa y dependiendo su tama\xf1o. "),r.Jb(63,"br"),r.cc(64," Los procesos tienen que correr en memoria contigua. Tiene un problema de fragmentaci\xf3n externa, por los huecos que quedan despu\xe9s de ejecuci\xf3n; La soluci\xf3n es mover el proceso, que se est\xe1n ejecutando, proceso de compresi\xf3n. Condensaci\xf3n: Fusi\xf3n de dos huecos contiguos. "),r.Kb(),r.Kb(),r.Kb(),r.Kb(),r.Lb(65,"div",4),r.Lb(66,"button",15),r.Sb("click",function(){return a.OnNext()}),r.Kb(),r.Kb(),r.Kb(),r.Kb(),r.Lb(67,"div",3),r.Lb(68,"button",16),r.Sb("click",function(){return a.OnInicio()}),r.cc(69,"Inicio"),r.Kb(),r.Kb(),r.Kb())},styles:[".atras[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:center}.btatras[_ngcontent-%COMP%]{height:100%}.header[_ngcontent-%COMP%]{margin-top:50px}.body[_ngcontent-%COMP%]{margin-top:40px}"]}),e})()}];let s=(()=>{class e{}return e.\u0275mod=r.Gb({type:e}),e.\u0275inj=r.Fb({factory:function(a){return new(a||e)},imports:[[n.b.forChild(c)],n.b]}),e})(),t=(()=>{class e{}return e.\u0275mod=r.Gb({type:e}),e.\u0275inj=r.Fb({factory:function(a){return new(a||e)},imports:[[o.b,s]]}),e})()}}]);